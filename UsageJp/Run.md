# Run

CCFinderSW の実行方法を記述します。

- `build/distributions/CCFinderSW-<version>.zip` を解凍してください．
- 解凍後も、ディレクトリは構造を保持してください．CCFinderSW.jar 単体では動きません．
  - 詳細は[Build.md](Build.md)も参照してください．
- 実行には Java 8 以上の動作環境を推奨します．（それ以下では未テスト）
- コマンドライン上で適宜引数を与えて実行します．
  - `./CCFinderSW D -d directory -l language -o outputtxt`
- CCFSW で出力されたクローンペア情報は，Gemini または CCFX で読むことができます．

## [D] CloneDetector のコマンドラインの引数

- -help
  - それなりのヘルプが出ます．

### 必須の引数

- `-d <arg>`
  - ソースファイルがあるディレクトリパスを入力します．
- `-l <arg>`
  - コードクローン検出の対象となる言語名を入力します．
  - オプションファイルを読み込む際に，この言語名を使用します．
- `-o <arg>`
  - クローンペア情報を出力したいファイル名を入力します．  
    例 `-o outputfile` と入力すると _outputfile.txt_ が作成される．
  - ccfx モードなら _outputfile.ccfxd_ が作成される．
  - ccfsw モードなら _outputfile_ccfsw.txt_ も作成される．

### 任意の引数

#### 字句解析・検出

- `-t <arg>`
  - 検出するコードクローンの最低トークン数（しきい値）を入力します．  
    例 `-t 90`のように数値を入力してください．
  - デフォルトは 50 です．引数を与えなければデフォルト値になります．
- `-w <arg>`
  - クローンペアの範囲を設定します。引数に与えられるのは 0, 1, 2 の 3 種類です。
  - `0` 全範囲
  - `1` ファイル内のみ
  - `2` ファイル間のみ
- `-b`
  - コードブロックを空白のインデントで認識します．
  - `-antlr` モードでは使用できません．
- `-antlr <arg>`
  - コメント除去・識別子判別で使用される情報を`src/main/dist/grammarsv4`内の文法ファイルから抽出します．
  - 通常のルールは使用できません．
  - 引数には対象ソースコードを認識するための拡張子の正規表現を入力してください．（拡張子を並べて間に縦棒を入れるだけです）
    ```
    - 例1: -antlr h|hh|hpp|hxx|c|cc|cpp|cxx
    - 例2: -antlr py
    ```
- `-charset <arg>`
  - 対象ファイルの文字コードを選択しています．
  - 全角文字などが使用されたソースコードの解析は，正しく文字コードを認識する必要があります．
  - sjis, utf8, euc, auto の 4 種類があり `-charset sjis` のように入力します．  
    _sjis_ 文字コード「Shift-JIS」で全ファイルを認識します．  
    _utf8_ 文字コード「UTF-8」で全ファイルを認識します．  
    _euc_ 文字コード「EUC-JP」で全ファイルを認識します．  
    _auto_ はファイル毎に，上記三種類の文字コードから自動認識を行います．処理に少し時間がかかります．
- `-g <arg>`
  - 対象ソースコードを N 個のグループに分けて検出します．
  - （メモリが少なくても検出できるようにする仕組みでしたが現在使用できません）
- `-nolx`
  - 字句解析部を省略します．つまり一度使った中間ファイルを再利用して、検出部の実行を繰り返すときに使えます．

#### 出力

出力には 4 つの形式があります．2 つ以上の形式で同時に出力することもできます．  
以下のどのオプションも含まれない場合には-ccf が含まれるものとして実行します．

- `-ccf`
  - Gemini(CCFinder)で開くことのできるファイル形式で出力します．
  - ファイル名は`outputFile.txt`となります．
- `-ccfx`
  - GemX(CCFinderX)の出力形式の ccfxd ファイルが作成されます．
  - ファイル名は`outputFile.ccfxd`となります．
- `-ccfsw <arg>`
  - CCFSW の出力形式でも出力します．
  - ファイル名は`outputFile_ccfsw.txt`となります．
  - \<arg> には `pair` か `set` を入力してください．（出力内容が変わります）
- `-json <arg>`
  - JSON フォーマットで出力します．
  - ファイル名は outputFile.json となります．
  - \<arg> には `+` か `-` を入力してください．（JSON のインデントの有無）

#### メトリクスフィルタリング

- `-tks <arg>`
  - クローン片に含まれるトークンの最低種類数でフィルタリングします．
  - 整数で入力してください．
  - 12 以上がおすすめです．
- `-rnr <arg>`
  - クローン片に含まれる非繰り返し部の最低割合でフィルタリングします．
  - 0 から 1 の間の小数で入力してください．
  - 0.3 ぐらいあれば多分大丈夫です．

### 引数なし，もしくはエラーのある引数での実行

- 引数なし，もしくはエラーのある引数での実行で usage が出力されます．

## 対象ソースコードについて

- 検出したいソースコード全てをあるディレクトリに入れ，そのディレクトリのパスを前述の引数(-d <arg>)で設定すれば OK です．
- CCFX モードを使用すると，ディレクトリ内に「.ccfxprep」というフォルダが作成されます．これは CCFX の Viewer を使用するときに必要です．

## 実行のための準備・条件

- 実行には，言語対応のコメントファイルと予約語ファイルが必要です．
  - コメントファイル
    - **最低限の記述が必要です．** 詳しくは[OptionFile.md](/UsageJp/OptionFile.md)で説明されます．
  - 予約語ファイル
    - 必須ではありませんが，置くことを推奨します．
    - ファイルが存在するとタイプ 2 までのコードクローンを検出し，そうでなければタイプ 1 のコードクローンを検出します．
- ファイルの置き場所
  - コメントファイルと予約語ファイルは`src/main/dist/comment`ディレクトリ，`src/main/dist/reserved`ディレクトリにそれぞれ置いてください．

## [P] PrittyPrinter のコマンドラインの引数

未実装です．

## [S] MetricsFiltering のコマンドラインの引数

未実装です．
