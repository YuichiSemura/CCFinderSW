# Run

- 実行にはJava 8以降の動作環境を推奨します．（それ以下では未テスト）  
- コマンドライン上で適宜引数を与えて実行します．  
   - `./CCFinderSW D -d directory -l language -o outputtxt` 
- CCFSWで出力されたクローンペア情報は，GeminiまたはCCFXで読むことができます．

## [D] CloneDetector のコマンドラインの引数  
- -help
   - それなりのヘルプが出ます．

### 必須の引数
- -d <arg>
   - ソースファイルがあるディレクトリパスを入力します．  
- -l <arg>
   - コードクローン検出の対象となる言語名を入力します．  
   - オプションファイルを読み込む際に，この言語名を使用します．
- -o <arg>
   - クローンペア情報を出力したいファイル名を入力します．  
   例 `-o outputfile` と入力すると *outputfile.txt* が作成される．
   - ccfxモードなら *outputfile.ccfxd*が作成される．
   - ccfswモードなら *outputfile_ccfsw.txt*も作成される．

### 任意の引数
#### 字句解析・検出
- -t \<arg>
   - 検出するコードクローンの最低トークン数（しきい値）を入力します．  
   例 `-t 90`のように数値を入力してください．
   - デフォルトは50です．引数を与えなければデフォルト値になります．
- -w \<arg>
   - クローンペアの範囲を設定します(0 <= detectionRange <= 2)
   - 0 全範囲
   - 1 ファイル内のみ
   - 2 ファイル間のみ
- -b
   - コードブロックを空白のインデントで認識します．
   - antlrモードでは使用できません．
- -antlr \<arg>
   - コメント除去・識別子判別で使用される情報を`src/main/dist/grammarsv4`内の文法ファイルから抽出します．
   - 通常のルールは使用できません．
   - 引数には対象ソースコードを認識するための拡張子の正規表現を入力してください．（拡張子を並べて間に縦棒を入れるだけです）
      ```
      - 例1: -antlr h|hh|hpp|hxx|c|cc|cpp|cxx  
      - 例2: -antlr py
      ```
- -charset \<arg>   
   - 対象ファイルの文字コードを選択しています．
   - 全角文字などが使用されたソースコードの解析は，正しく文字コードを認識する必要があります．
   -  sjis, utf8, euc, auto の4種類があり `-charset sjis` のように入力します．  
   *sjis* 文字コード「Shift-JIS」で全ファイルを認識します．  
   *utf8* 文字コード「UTF-8」で全ファイルを認識します．  
   *euc*  文字コード「EUC-JP」で全ファイルを認識します．  
   *auto* はファイル毎に，上記三種類の文字コードから自動認識を行います．処理に少し時間がかかります． 
- -g \<arg>
   - 対象ソースコードをN個のグループに分けて検出します．
   - （メモリが少なくても検出できるようにする仕組みでしたが現在使用できません）
- -nolx
   - 字句解析部を省略します．一度行った実行を繰り返すときに使えます．

#### 出力
出力には4つの形式があります．2つ以上の形式で同時に出力することもできます．  
以下のどのオプションも含まれない場合には-ccfが含まれるものとして実行します．
- -ccf
   - Gemini(CCFinder)で開くことのできるファイル形式で出力します．
   - ファイル名は`outputFile.txt`となります．
- -ccfx  
   - GemX(CCFinderX)の出力形式のccfxdファイルが作成されます．
   - ファイル名は`outputFile.ccfxd`となります．
- -ccfsw \<arg>  
   - CCFSWの出力形式でも出力します．  
   - ファイル名は`outputFile_ccfsw.txt`となります．
   - \<arg> には `pair` か `set` を入力してください．（出力内容が変わります）
- -json \<arg>
   - JSONフォーマットで出力します．
   - ファイル名はoutputFile.jsonとなります．
   - \<arg> には `+` か `-` を入力してください．（JSONのインデントの有無）

#### メトリクスフィルタリング
- -tks \<arg>
  - クローン片に含まれるトークンの最低種類数でフィルタリングします．
  - 整数で入力してください．
  - 12以上がおすすめです．
- -rnr \<arg>
  - クローン片に含まれる非繰り返し部の最低割合でフィルタリングします．
  - 0から1の間の小数で入力してください．
  - 0.3ぐらいあれば多分大丈夫です．
### 引数なし，もしくはエラーのある引数での実行
-  引数なし，もしくはエラーのある引数での実行でusageが出力されます．

## 対象ソースコードについて
- 検出したいソースコード全てをあるディレクトリに入れ，そのディレクトリのパスを前述の引数(-d <arg>)で設定すればOKです．

- CCFXモードを使用すると，ディレクトリ内に「.ccfxprep」というフォルダが作成されます．これはCCFXのViewerを使用するときに必要です．

## 実行のための準備・条件

- 実行には，言語対応のコメントファイルと予約語ファイルが必要です．
   - コメントファイル
      - **最低限の記述が必要です．** 詳しくは[OptionFile.md](/UsageJp/OptionFile.md)で説明されます．

   - 予約語ファイル
      - 必須ではありませんが，置くことを推奨します．
      - ファイルが存在するとタイプ2までのコードクローンを検出し，そうでなければタイプ1のコードクローンを検出します．

- ファイルの置き場所
	- コメントファイルと予約語ファイルは`src/main/dist/comment`ディレクトリ，`src/main/dist/reserved`ディレクトリにそれぞれ置いてください．

## [P] PrittyPrinter のコマンドラインの引数 
未実装です．

## [S] MetricsFiltering のコマンドラインの引数
未実装です．